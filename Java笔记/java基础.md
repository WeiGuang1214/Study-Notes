##### 文档注释

- ​	javadoc -d 文件夹名 -xx -yy Demo3.java

- ​	写在类之前，可以显示当前文档的相关信息

- ```java
  /**
  *@author XXX
  *@version 1.0
  */
  ```

- ​	相对路径：当前目录开始定位形成的一个路径

- ​	..\表示回到上一级

- ​	..\ ..\hello.java两个表示回到上两级

- ​	绝对路径：从根目录出发形成的路径

- ​	d:\abd\test.....\hello.java


##### DOS命令

- ​	dir	查看当前文件夹的文件

- ​	dir d:\xxx	查看当前具体文件夹里的文件

- ​	help cd 	查看当前指令的作用

- ​	cd /D c:	切换到其他盘

- ​	cd 相对路径或者绝对路径	切换到其他具体目录下

- ​	cd ..	切换到上一级

- ​	cd \	切换到根目录

- ​	tree	查看当前指定目录的所有子目录，目录树

- ​	cls	清屏

- ​	exit	退出DOS

- ​	md	创建目录

- ​	rd	删除目录

- ​	copy 拷贝文件

- ​	del 删除文件

- ​	echo 输入内容到文件

- ​	type	输入空文件

- ​	move	剪切


##### 数据类型

##### 引用数据类型：数组、类、接口

##### 基本数据类型：

- ​	byte 字节，一个字节8bit

- ​	int 4byte

- ​	short 2byte

- ​	long 8byte，500L，后面接L

- ​	float 4byte，浮点数=符号位+指数位+尾数位，尾数部分可能丢失，造成精度损失(小数都是近似值)，后面接f或者F

- ​	double float 8byte，

- ​	浮点数的计数方式有两种：十进制计数，一定要有小数点，5.1,5.10F，.512F，.512==0.512；

- ​	科学计数法：512E-2==512*10的-2次，521E2==52100，double / float和int计算还是float，特别重要：判断两个数是否相等，应该是两个数差值的绝对值小于10的-6，因为有可能存在误差

- ​	char 单个字符，char c1 = 'a';	char c2 = '\t';	char c3 = '飞';	char c4 = '85'；char类型可以加减，对应数值

- ​	A-Z是65-90

- ​	a-z是97-122

- ​	boolean 布尔，逻辑值，1byte，true or false


##### 数据类型自动转换：

- ​	小自动转大，自动转换类型：

- ​		char->int->long->float->double

- ​		byte->short->int->long->float->double

- ​		char和byte不能自动转换

- ​	大转小要强制转换：


​		

##### Java API文档

​	API是Java提供的基本编程接口，由Java自带的类还有相关的方法，中文在线文档：https：//www.matools.com；包里有接口、类、异常![image-20240718203857619](C:\Users\微光\AppData\Roaming\Typora\typora-user-images\image-20240718203857619.png)

##### 运算符

- 注意/前后的类型，      类似10/4=2,10.0/4=2.5

- -10 % 3= -1    a%b=a-a/b*b

- ##### 当a是小数时，a % b = a-(int)a  /b * b，小数运算是近似值

- 10% -3= 1  ，注意公式

- -10 % -3 = -1  ，可以理解为散列表向左向右，以0为中轴

- 自增，自减，i++，i--，++i，--i，注意独立使用和结合赋值使用的区别

- ##### 关系运算

- ==    !=  < >   <=   >=    instance of  判断是否属于类的对象

- ##### 逻辑

- &&  ||    且，或

- &  逻辑与，作用和&&相同，但是前后都要判断，|  逻辑或，同样两边都要判断

- !a  非

- a ^ b    逻辑异或，ab不同的时候为true ，否则为false

- ##### 赋值

- == ，+= ，-=    复合赋值会进行类型强制转换，注意报错

- ##### 三元运算符

- result = a>b ? a++ : b-- ;	注意先处理返回 和 后计算表达式的运算	要注意类型的转换，三元不可以强制转换

- ##### 运算符的优先级

- 只有   单目运算、赋值运算  是从右往左	，其余都是从左往右

- ##### 运算顺序：

- 1、()   ,   {} 等

- 2、单目运算 ++ --

- 3、算术运算符

- 4、位移运算符 <<  >> >>> 

- 5、比较运算符

- 6、逻辑运算符

- 7、三元运算符

- 8、赋值运算符

- 先单目，再算术运算，再比较  再看逻辑大小


##### 标识符规范

​	驼峰命名，不能用关键字和保留字，注意特殊字符，

##### 输入

- java.util.Scanner 类

- Scanner scanner = new Scanner(System.in);

- String name = scanner.next() 字符串

- int a = scanner.nextInt() 什么类型就用什么结尾

- double salary = scanner.nextDouble() 什么类型就用什么结尾


#### 进制转换

- ##### 1、二、八、十六转十进制

- 存在0b开头，2：个位开始乘2的(位数-1)次方，求和

- 0开头八进制，8：个位开始乘8的(位数-1)次方，求和

- 0x开头十六进制，16：个位开始乘16的(位数-1)次方，求和

- ##### 2、十进制转二、八、十六

- 除余再整除，保留余数，逆置就是进制转换结果

- 0b

- 0

- 0x

- ##### 3、二进制转八、十六进制

- 2转8：从低位开始每三个数一组，转成对应10进制即可，最后数排起来就是8进制

- 2转16：从低位开始每四个数一组，转成对应10进制即可，最后数排起来就是16进制

- ##### 4、八、十六进制转二进制

- 8转2：每一位转成3位2进制

- 16转2：每一位转成4位2进制

- ##### 位运算

- ##### 二进制最重要的第一位是符号位，0是正，1是负

- ##### 正数的原码、反码、补码都一样，三码合一

- 负数求反码，负号位不变，其余的求反码

- 负数的补码=反码+1

- 负数的反码=补码-1

- 0的反码补码都是0

- 右移>>：移动几位，除以2的几次方，整除形式

- 左移<<：移动几位，乘以2的几次方

- 无符号右移>>>：

- ##### 这四则运算都是先转换为补码再运算

- ~按位取反：0变1,1变0，正数的反码是其本身，*负数的反码是符号位保持不变*，其余位取反

- &按位与：每位每位的对比，同时为1结果为1，否则为0

- |按位或：至少有一个1结果为1，否则为0

- ^按位异或：两个一个为0一个为1，否则为0

- ##### 结果返回要转换为原码（最后print为10进制），注意负号的情况


##### 顺序控制

- 分支控制 if

- 双分支 if else、嵌套

- 多分支switch：


```java
switch(表达式):{  //表达式只能是 byte int short char string enum[]
    case '常量1':
    	语句块1;
    	break;  //  有退出的时候，匹配了退出，否则没有匹配，继续往后判断
    // 如果匹配了没有break，会一直执行后面的语句块，default也会执行，直到break   穿透
    case '常量2':
    	语句块2: 
    	break; 
    default:  // 如果前面没有匹配就默认执行，然后break，可有可无
    	语句块;
    	break;
}
```

- 需要注意的是表达式和case后的常量类型一致或者可以相互转换，char->int，case后必须常量，加 ' '

- ##### for循环  

- for(int i = 0;i<100;i++){     //   ；；为死循环

- }   // i++可以写入循环体内，i的作用域在循环体内也有效

- ##### while循环

- while(条件){

- 循环体

- }

- ##### do while循环。dowhile是关键字

- do先会执行一次，不论循环对错都会执行一次

- do{

- }while(条件);

- 循环条件返回的是布尔值的表达式

- ##### 多重循环控制，嵌套，注意内外变量

- ##### break跳出循环  continue 继续下一次循环

- break可以利用标签label指明要终结的是哪一层循环


```java
label1:
for(int j =0;j<4;j++){
label2:
	for(){
		if(){
			break label1;
		}
	}
} //break到哪，推出到哪个label
```

- 没有label默认退出最近的循环

- ##### return 返回值，或return;，表示跳出所在的方法，如果在main里面return就是结束程序

- ##### 数组，数组是引用类型，类型是Object


##### 动态初始化，数组初始化没赋值都是类型的默认值

- 1、类型 名字[] = new 类型[大小]   int a[] = new int[10];    数组名[下标]  a[2]  从0开始
- 2、先声明，再new一个，先声明再创建   int a[];   a[] = new[10];

- 3、静态初始化，直接赋值，下标越界会报错

##### 数组赋值机制，数组复制是引用，传递的是地址，地址传递的修改会修改原本的数据结构

​	int a1[] = {1,2,3};  int a2[] = a1;，不修改值的拷贝是for循环复制

##### JVM的内存：栈、堆、方法区

- 数组的翻转，原地换位

- 数组动态(利用do while，复制给一个大一位的数组)、静态扩容


##### 数组应用：排序、查找、栈、队列、顺序存储

- 二维数组

- ```java
  for (int i=0;i<a.length;i++){
              for (int j=0;j<a[i].length;j++){
    //二维数组  第一维长度：a.length  ，第二维长度：a[i].length
              }
          }
  ```

- 动态初始化：int a //[ ]//[ ] = new int //[2]//[3]

- 二维数组，一维的a[]其实是存的数组名，a//[]//[]为二维数组的值，地址取值方式

- a指向的是数组首地址，以此类推

- 动态定义：int a//[]/[];  ，再new  a = new int [2]//[3] 


##### 类与对象

​	类class .属性，.方法     生成对象  ，调用属性方法

```java
class AA{

	String aaa;
	基本数据类型、引用、数组、类的对象
	int num;
}
AA xiaoa = new AA()
xiaoa.aaa=
xiaoa.num=
```

#### 方法

- ##### 访问修饰符

- public   protected   默认  private

- 类的对象开辟空间

- ##### Java 内存的结构分析

- 1、栈：存储基本的数据类型，局部变量

- 2、堆：存放对象，数组等

- 3、方法区：常量池、类加载信息

- 创建流程：先加载类信息(属性和方法)，在堆中开辟空间默认初始化，把地址返回给对象，进行指定初始化

- ##### 成员方法

- 类里面定义，对象调用，程序执行到方法才开辟空间，注意方法返回值，输入参数

- ##### 访问修饰符控制方法的访问范围 public  private  默认不写  protected

- 方法只能有一个返回值，方法参数传值，数组等等引用类型，传递的是地址，可以修改到具体变量

- ##### 递归，注意递归出口，递归条件

- ##### 方法的重载

- ##### 	重载的前提是方法名相同，允许多个同名方法存在，但是形参列表，重点是参数类型、参数个数、顺序不能一样，对方法的修饰符、返回类型无要求

#### 可变参数

- 允许把同一类中多个同名同功能但参数个数不同的方法，封装成一个方法，可以通过可变参数实现

- int...表示类型int的0-多个参数，nums可以当可变场数组，实参可以是数组，可变参数就是数组，可以通过下标访问全部参数，可变参数可以和普通参数写在一起，但是可变参数一定要放在最后，一个形参列表最多只能一个可变参数

- ```java
  public int sum(int... nums){
  
  }
  ```

- 全局变量（类内属性,默认初始化），局部变量（方法内，需要初始化）的作用域

- 全局变量可以用访问控制符修饰，但是局部变量不可以

#### 构造方法/构造器，对新对象的初始化

- 构造器的修饰符可以默认，也可以随意，
- 构造器没有返回值
- 方法名必须和类名一致
- 构造器的调用是由系统完成的
- 构造器也能重载
- 系统有无参默认的构造器，自己定义也可以无参构造器
- 对象创建的流程，栈、堆、方法区
- 注意无参构造器中嵌套有参构造器this()
- ##### this关键字

​	Java虚拟机给每个对象分配this，代表当前对象，this.name=name，this.hashCode可以简单看成内部地址，哪个对象调用，this就代表哪个对象，this只能在构造器中使用，可以在一个构造器中访问另外一个构造器，this可以直接使用构造器，this()，里面赋值传参

#### 面向对象编程

- **IDEA快捷键：**

  - **ctrl +d 删除行**
  - **ctrl+alt+向下光标  复制当前行**
  - **alt+/ 补全代码**
  - **ctrl+/ 添加注释，再按取消**
  - **导入该行需要的类，alt+enter**
  - **快速格式化，ctrl+shift+L**
  - **快速运行程序，自己定义 ctrl+r**
  - **生成构造器等 alt+insert**
  - **查看类的层级关系   ctrl+H**
  - **定位到哪个类的方法  ctrl+B** 
  - **自动分配变量名    .var**     例：new Scanner(System.in).var

- 包

  - package 包名;  打包，import导入包，管理类，package只能放在第一句
  - 命名规则：数字、字母、下划线、小圆点，但是不能数字开头且关键字、保留字     ：   公司名.项目名.模块名
  - 基本包，自动导入：java.lang.*
  - 工具包：java.util.*
  - 网络包：java.net.*
  - GUI界面开发：java.awt.*

- ##### 访问修饰符

  - public  对外公开
  - protected 子类和同一个包中的类公开
  - 默认 没有修饰符，对同类、同包公开
  - private 私有，只有类本身访问
  - 只有默认和public可以修饰类


- ##### 封装

  - 把抽象出的数据（属性）和对数据的操作（方法）封装在一起，数据被保护在内部，在程序的其他部分通过被授权的方法操作属性
  - 隐藏实现细节、可以对数据进行验证，保证安全合理
  - 实现封装：
    - 属性私有化，private，外部不能修改
    - 公共set方法，用于对属性判断并且赋值，将构造器和set方法结合在一起写
    - 提供一个公共get方法，用于获得属性的值

- ##### 继承

  - 解决代码复用，降低冗余，从父类中定义相同的属性和方法，用子类extends继承父类即可使用属性和方法
  - class 子 extends 父{}
  - **子类继承所有属性和方法，但是私有属性不能在子类直接访问，但是可以通过父类的公共方法访问**
  - 子类必须首先调用父类的无参构造器，完成父类的初始化，如果父类没有无参构造器，就要用super关键字指定用父类哪个构造器构造，super(参数列表)
  - super()在构造器中只能放在第一行，并且super()和this()不能同时存在一个构造器中
  - Java所有类都是Object的子类，只能单继承
  - 父类的构造器调用不限于父类，可能一直调用祖先的构造器

- ##### super关键字

  - super代表父类的引用，用于访问父类的属性、方法和构造器
  - 父类属性：super.属性，但是不能访问私有属性
  - 父类方法：super.方法，但是不能访问私有方法
  - 构造器：super(参数列表 )


- ##### 方法重写/覆盖   override

  子类继承父类的方法后重写父类的方法，定义的形式一样：名称、返回类型、参数列表一样

  - 子类不能缩小父类的访问权限
  - 方法重写/覆盖   override

- #### 多态

  - 多态建立在封装和继承的基础上-->两个(对象)类有继承关系
  - 方法的多态：重写和重载
  - 对象的多态(核心)：
    - 对象的编译类型和运行类型可以不一致
    - 编译类型在定义对象的时候就确定了，不能改变
    - 运行类型是可以变的
    - 编译类型看定义=左边，运行类型看=右边，属性的值只看编译类型，方法的调用看运行类型
    - getclass()查看运行类型
  - **多态：向上转型**
    - 父类的引用指向子类的对象     父类  引用名 = new 子类()
    - 可以调用父类的所有成员，遵守(遵守访问权限)，不可以调用子类的特有成员，因为在编译阶段能调用的成员是由编译类型决定，
  - **多态：向下转型**
    - 子类的引用指向父类的对象   子类  引用名 = (子类类型)父类引用，强制转换引用，地址一样
    - 只能强转父类的引用，不能强制转换父类的对象
    - 可以调用子类类型中所有的成员
    - 要求父类的引用必须指向的是当前目标类型的对象
    - 属性没有重写之说，属性的值只看编译类型
    - instanceOf  判断xx运行类型是否属于x类型或者子类型   a  instanceOf  b  true or false

- #### **Java动态绑定机制**

  
  - 当调用对象方法的时候，该方法会和对象的内存、运行类型绑定
  
  - 当调用对象属性的时候，没有动态绑定机制，哪里声明(当前类)，哪里使用
  
- #### 多态数组

  - 数组的定义类型为父类类型，里面保存的实际元素类型为子类类型，编辑类型是父类，运行类型实际根据JVM来
  - 如何调用子类特有的方法，比如Teacher对象，统一放在数组中，调用每个对象的say

- #### 多态参数

  - 方法定义的形参类型为父类类型，实参类型允许为子类类型
  
- ##### Object类详解

  
  - equals方法，equals和==的区别，==是比较运算符，equals是方法
  
  - Object内的equals判断对象是不是同一个，equals不能判断值是否相等，Object子类重写后的equals判断值，String的equals重写过了，判断值是否相等
  
  - ==既可以判断基本类型也可以判断引用类型，值/地址(对象)是否相等
  
  - 对于基本数据类型，==是判断值是否相等
  
- hashCode返回hash码值

  - 两个引用，如果指向的是同一个对象，哈希值就一样，不同则不一样
  - 哈希值主要是根据地址号，但是不等于地址，Java跑在虚拟机上，所以不能获得内部地址
  
- ##### toString

  
  - 返回类的全类名和hashcode
  - 重写toString，输出对象的属性值，直接输出一个对象的时候，默认调用toString
  
- ##### finalize类


    - 对象被回收的时候，释放空间，调用finalize方法，子类可以重写该方法


    - 垃圾回收机制由系统自动调用，但是也可以自己主动调用，System.gc()，主动运行垃圾回收器，不会造成程序阻塞



- ##### 断点调试


    - 在断点调试的过程中，是运行状态，是以对象的运行类型来执行的
    - F7 跳入方法内；F8逐行运行；shift+F8 跳出方法；F9 resume 执行到下一个断点


    - 强制进入源码   alt shift F7


    - 方法定义的形参类型为父类类型，实参类型允许为子类类型


- ##### 类变量

  - static 类变量，静态变量，会被该类所有的对象实例共享，不管存在哪里，
  - 类变量在类加载的时候就生成了
  - 通过类名.变量名；对象.变量名；
  - 在所有对象共享一个变量的时候，把变量声明成类变量
  - 属性(实例变量)不能通过类名访问，只能通过对象访问
  - 类对象的生命周期随类的加载和销毁而加载和销毁


  - ##### 类方法


    - 类名.方法名；对象名.方法名，static方法，静态方法
    
    - 当成工具直接调用
    
    - 类方法中不允许有this和super关键字
    
    - 静态方法只能调用静态变量和静态方法
    
    - 非静态方法既可以访问静态变量、静态方法，也可以访问非静态变量、非静态方法



- main方法

  - JAVA虚拟机调用，所以main方法必须是public
  - java虚拟机调用main方法不需要创建对象，所以是static类型的
  - args字符串数组用来保存java执行命令的参数
  - main是静态方法，所以可以使用静态变量和方法
  
- 代码块

  - [修饰符]{代码}；
  - 修饰符要写只能写static
  - 相当于是另一种的构造器，可以做初始化操作，如果多个构造器有重复的语句，就可以抽象出来，放在代码块里面，代码块的调用优先于构造器
  - static代码块，随着类的加载只会执行一次，静态代码块只能调用静态成员
  - 普通代码块随着对象创建都会执行，创建一次执行一次
  - 一个类加载时候代码块和构造方法的调用顺序：

    - 父类静态代码块的执行按顺序调用，谁在前就先执行
    - 子类静态代码块的执行按顺序调用，谁在前就先执行
    - 父类普通代码块的执行按顺序调用，谁在前就先执行
    - 父类构造器
    - 子类普通代码块的执行按顺序调用，谁在前就先执行
    - 子类构造器
    - 构造器其实隐藏了super()和调用普通代码块的语句
  
- 类在什么时候加载？

  - 创建对象实例时（只加载一次）
  - 创建子类对象实例时，父类会被加载
  - 使用类的静态成员（静态方法，静态属性）
  
- 单例设计模式

  - 静态方法和属性的经典使用
  - 单个对象实例从头用到尾
  - 饿汉式：

    - 构造器私有化、类的内部创建对象、向外暴露一个公共方法getInstance、代码实现
  - 懒汉式：
    - 构造器私有化、内部定义一个私有属性对象、向外暴露一个公共方法getInstance，在getInstance方法内，如果检查属性对象是null就创建对象，返回对象，保证单例
  
- final关键字
  - 修饰类、属性、方法、局部变量
  - 不希望类被继承、不希望被子类覆盖或重写、不希望某个属性的值被修改、不希望某个变量被修改
  - 定义时必须初始化，但是可以在构造器，代码块中赋值
  - final类不能被继承，但是可以实例化对象
  - 如果不是final类，但是如果方法是final，是可以被继承的
  - 如果一个类已经是final类，就不用再把方法变成final方法

- 抽象类
  - 父类的某些方法需要声明，但是不知道怎么实现的时候，可以用抽象方法，这个类叫抽象类
  - 没有方法体：
    - abstract void eat();   如果存在抽象方法即要声明为抽象类   abstract class
    - abstract只能修饰类和方法，如果一个类继承了抽象类就必须实现抽象类的所有方法，否则自己也是一个抽象类
    - 抽象方法不能被private final static来修饰，因为这些修饰和重写相违背
    - 抽象类重点是设计，子类继承后实现方法具体内容，抽象类可以没有抽象方法

- 抽象模版模式
  - 把公共代码放在父类继承，个性化任务用抽象类，子类重写实现各自功能

- 接口interface，给出一些没有实现的方法，封装到一起，在某个类具体使用的时候再把方法写出来

  - ```java
    interface{
    	属性
        方法(抽象方法、默认实现方法、静态方法)
    }
    class 类名 implements 接口{
        自己属性
        自己方法
        必须实现的接口的抽象方法
    }  //接口中可以有方法的具体实现，实现接口的时候需要把接口内的所有方法都实现
    ```

    

  - public interface UsbInterface{	接口相关的方法}

  - public class phone implement UsbInterface{         }

  - 接口类声明方法，implement具体实现重写方法

  - 接口不能实例化，所有方法都是public，抽象方法可以不用abstract修饰

  - 抽象类实现接口可以不用实现接口的方法

  - 可以同时实现多个接口，逗号隔开

  - **接口中的属性其实是public static final 的**

  - 接口的修饰符只能是public和默认，这个和类一样，接口只能继承接口，不能继承类

  - 接口机制是对继承机制的补充，子类如果需要扩展功能需要实现接口，接口更灵活

- 接口的多态特性

  - 1、多态参数：接口的引用可以指向实现了接口类的对象

  - 2、多态数组：和继承一样，如果接口引用需要实现类特有的方法，需要向下转型再调用

  - 3、多态传递：类似于子类的多层继承，接口的继承，可以实现到父类接口

  - 一个类可以同时继承和实现接口

- 内部类

  - **类的五大成员：构造器、属性、方法、代码块、内部类**

  - A类里面嵌套B类：内外只是相对关系，内部类、外部类、外部其他类

  - 局部位置：

    - **局部内部类，有类名**

      - 地位是局部变量，不能用访问修饰符，但是可以用final，只能在定义它的方法和代码块中用，访问方法需要创建内部类对象，如果成员重名就就近原则，访问外部对象：类名.this.成员

    - **匿名内部类，无类名(重点)**

      - 本质是类，内部类，没有名字，**同时也是一个对象，可以直接new一个接口然后重写方法**

      - ```java
        new 类或接口(参数列表){类体};
        ```

        anonymous ，底层会分配一个匿名类名，用一次就销毁，简化开发，注意使用时和对象的创建分开，需要注意{};

        参数列表会传递给构造器

        可以调用匿名内部类的方法，直接匿名内部类.方法，也可以建好对象后.方法

        **匿名内部类如果重名，是一种继承，并且可以重写方法**

    - **成员内部类**，没有static修饰，可以添加任意访问修饰符，本质是成员变量

    - **静态内部类**，有static修饰，静态成员，作用域和其他成员一样，为一个整体

      #### 枚举

- enum，一组常量的集合，**只能读不能修改**

  - 1、自定义类实现的枚举

    - 在类的内部直接创建一组对象

    - 私有化构造器

    - 对外暴露对象public static 类型，可以用final

    - 只有get方法，不用set

  - 2、使用enum关键字定义的枚举

    - 如果使用enum实现枚举，要求把常量对象定义在前面，用逗号隔开

    - 如果使用无参构造器创建常量对象，小括号和参数可以省略

    - ```java
      enum class{
          duix1(a,b),duix2(a,b);
          私有属性；
          私有构造器
      }
      ```

      enum枚举实际上继承了final Enum类，

      ```java
      枚举对象.name() 返回名字
      枚举对象.ordinal() 返回次序、编号
      类名.values() 返回数组，里面是枚举对象
          A[] values = A.values();
      	for(A a:values){} //增强for循环
      类名.valueOf("String") 把字符串常量转成枚举对象，要求常量名是存在的枚举对象
      枚举对象.compareTo(枚举对象) ,比较两个枚举对象的编号是否相同，返回值是A-B编号
      ```

      enum类实现接口的问题：

      ​	1、不能继承任何类，已经继承Enum了

      ​	2、枚举类和普通类一样可以实现接口


- 注解annotation，源数据，用于修饰解释包、类、方法等信息
  - 使用的时候要在前面加一个@
  - @Override：重写父类方法，语法校验，如果真的重写，编译通过，没有就编译不通过
  - @Deprecated：某个方法已经过时，但是可以用
  - @SuppressWarnings({})：抑制编译器警告，当不想看到编译器警告的时候用这个注解，在{}内填写不想显示的信息
  
- 异常

  - 利用try-catch机制
  - try{代码块}catch(Exception e){getmessage}
  - 分为error(资源耗尽、栈溢出)和exception(编译、运行)两类
  - exception：

    - 数组越界、空指针、算数异常、类型转换异常
  - 异常处理：

    - try-catch-finally，程序员捕获自行处理，不管有没有异常都要执行finally
    - throws，往上一级抛出，最终交给JVM处理，JVM直接输出异常程序并且中断，如果没有显式try catch就是默认throws

  - 自定义异常

    - 编译异常继承exception，运行异常继承runtime exception，编译类型需要在方法显式throws，运行类型可以直接方法内throw
    - throw和throws的区别：
    - throws是异常处理的一种方式(方法声明中)，后跟异常类型；throw是生成异常对象的关键字(方法体内)，后跟异常对象；
  
- 包装类

  - 基本数据类型对应的包装类，具有类的特征，可以调用类中的方法
  - Boolean、Character、Byte、Short、Integer、Long、Float、Double，包装类是number的子类
  - int和String的相互转化：i.toString、String.valueof(i)、

    - String str = “123”；Integer i = new Integer(str)、Integer i = Integer.parseInt(str)
  - 常用方法：
  
    - MIN_VALUE,返回最小值
    - MAX_VALUE,返回最大值
    - Character类：
    - isDigit('a')，判断是不是数字
    - isLetter('a')  判断是不是字母
    - isUpperCase('a') 判断是不是大写
    - isLowerCase('a') 判断是不是大写
    - isWhitespace('a') 判断是不是空格
    - toUpperCase('a')  转大写
    - toLowerCase('a')  转小写
    - 只要是基本数据类型，==判断的是值，否则是判断引用对象是否一个
  
- String类

  - String字符串用来保存字符序列，可以用数组初始化，不能被继承，字符串对象指定之后不能改变地址，但是可以改变字符串内容，不可变，如果String是相同对象，返回的就是同一个地址
  - 1、直接赋值：先看常量池里面有没有，有就指向地址，没有就创建再指向
  - 2、调用构造器创建String对象：先在堆里面创建空间，内部有value属性，然后再指向常量池，没有则创建，最终指向的是堆里面的空间
  - 如果是字符串相加，是在常量池新增字符串对象，如果是对象相加，是在堆里面创建对象
  - String常用方法：
    - equals，判断值相等
    - equalsIgnoreCase，忽略大小写判断是否相等
    - length，长度
    - indexOf，字符第一次出现的下标
    - lastIndexOf，字符最后一次出现的下标
    - substring，截取指定范围的子串
    - trim去掉前后空格
    - charAt，获取某索引处的字符
    - concat，拼接
    - replace，代替
    - split，以X分隔，返回数组
    - toCharArray，转成字符数组
  
- StringBuffer类，线程安全

  - 可变的字符序列，里面放的是字符串变量，value放在堆内，大小可以变
  - String->StringBuffer可以指定char[]大小，StringBuffer stringbuff = new StringBuffer(100)；
  - toString也可以转成字符串，也可以用String的构造器
  - 常用方法：
    - append、delete、replace、insert、length
  
- StringBuilder类

  - 单线程使用，线程不安全
  - 和StringBuffer兼容，用在字符串缓冲区被单个线程使用的时候，大多数时候比StringBuffer快，主要用append和insert方法
  - 大量字符串修改用StringBuffer或StringBuilder
  - 单线程用StringBuilder，多线程用StringBuffer
  - 字符串很少修改用String

- Math类

  - 基本数学运算方法

    - abs绝对值
    - pow求幂，x的y次
    - ceil大于等于该参数的最小整数，转成double
    - floor小于等于该参数的最大整数，转成double
    - round四舍五入，返回long
    - sqrt开方，返回double
    - random 返回0-1之间的double随机数  0<=  x<1  a<=<=b的随机数：(int)(a+Math.random()*(b-a+1))
    - max、min最大最小

- Arrays类

  - Arrays.toString ，显示数组信息
  - Arrays.sort，排序，底层快排
  - Arrays.binarySearch,二分查找，要求必须有序
  - Arrays.copyOf,复制数组
  - Arrays.fill，用xx填充，覆盖数组
  - Arrays.equals ，比较两个数组元素一致
  - Arrays.asList ， 把数组转化成列表

- System类
  - 常用方法：
    - exit，退出当前程序
    - arraycopy，复制数组
    - currentTimeMillis，返回当前时间距离1970-1-1的毫秒数
    - gc，垃圾回收机制
  
- 大数类


  - BigInteger，运算不能用+-*/

    - 用字符串的方式new对象
    - add加、subtract减法、multiply乘法、divide除法

  - BigDecimal，大精度小数

    - 也用字符串构建
    - 也需要单独创建个对象，并且用方法实现运算add加、subtract减法、multiply乘法、divide除法(用BigDecimal.ROUND_CEILING保存精度)

- Date类、Calendar、


  - Date：

    - 日期精确到毫秒，SimpleDateFormat格式化解析日期，日期to文本，文本to日期+
    - 通过毫秒数得到日期，parse，把字符串日期转Date

  - Calendar：

    - 抽象类，构造器私有，用getInstance获得实例
    - 通过对象.get获得Calendar的一个字段

  - LocalDate日期、LocalTime时间、LocalDateTime日期时间、DateTimeFormatter格式化日期、Instant时间戳

    - now当前时间对象，get获得字段，plus和minus可以对时间进行加减

- 集合


    - 动态保存任意多个对象，方便操作，add，remove，set，get等


    - 单列集合只放值，双列集合放KV对



  - collection单列集合


      - add添加、remove删除、size大小、isEmpty判空、clear清空、addAll添加多个、cointainsAll查找多个、removeAll



      - 增强for：for(Object i：nums) ，和迭代器不同



      - 迭代器Iterator，通过.iterator新建迭代器对象，通过while遍历，再次遍历需要重置迭代器，
    - next，下一个元素并返回
    
    - hasNext，判断是否有下一个元素，remove删除



```java
Iterator iter = col.iterator();
while(iter.hasNext()){
    Object o = iter.next();
}
```


​      

  - (1) List，有序，添加顺序和取出顺序一致，并且元素可以重复，add，remove，set，get按索引，subList，查改较多的用ArrayList，增删较多的用LinkedList，可以通过索引获得元素，是Collection的子接口
    - ArrayList

      - 可以存null，是由数组实现的，基本等同于vector，线程不安全，所以多线程不建议使用ArrayList，底层代码扩容机制：无参：容量初始为0，->10，再变为1.5倍，有参：容量指定，如需扩容直接1.5倍
    - LinkedList
      - 实现了双向链表和双端队列，元素可以重复，可以null，线程不安全，没有实现同步
      - 底层是双向链表，每个节点node，删除添加不是数组完成的，效率较高，first和last指针

    - Vector
      - 底层也是数组，是线程同步，线程安全的synchronized，扩容如果是无参，默认10，满了2倍，有参直接2倍扩容


  - (2) Set，无序，添加和取出顺序不一样，没有索引，不允许重复元素、所以对多包含一个null，也是Collection的子接口，但是不能使用索引获取元素，可以用增强for和迭代器循环，但是取出的顺序是固定的
    
    - HashSet
    
      - 实现了set接口，底层实际上是HashMap，不保证存取顺序一致，HashSet在底层扩容是用链式哈希表，数组+链表，Java8中哈希表链表长度>8，tabl>=64会变成红黑树
      - 添加逻辑：先比较哈希值(hashCode)，哈希值相同的会放在同一个地址下的链表，然后判断equals是不是值相同，相同就添加，否则添加，所以String重写equals方法和hashCode方法，所以new String的时候就无法添加，其他类也是一样，如果重写就无法添加new对象
      - LinkedHashSet，继承HashSet，底层是LinkedHashMap，底层维护数组+双向链表，依旧根据元素的hashCode决定存放位置，通过底层的双向链表保证了元素的次序，不允许添加重复元素
    - TreeSet


- Map双列集合，K-V对

  - 用于保存具有映射关系的Key-value；map中的Key-value可以是任何对象，被封装在HashMap$Node中；Key不允许重复，实现原理和HashSet一样；但是Value可以重复，key关键字相当于索引，key和value都可以为null但是key只能有一个，value可以多个



    - HashMap
    
    - put添加、添加key相同的value会覆盖上一个value，经常用String作为key；get(key)获取对应的value；
    - size()，isEmpty()，containsKey()查找是否存在，containsValue()，remove(key)或者kv对、putAll(Map)、clear()、keySet关键字集合、values()值的集合、equals判断相同，getOrDefault返回value、entrySet返回entry集合
    - 遍历方法：1、获得keySet，通过key增强for获得value；2、迭代器获得key，迭代get；3、把所有value取出，可以使用所有的Collection方法；也可以通过entrySet使用增强for和迭代器，向下转型成Map.entry
    HashMap没有实现同步机制，所以是线程不安全的


    - Hashtable
    


    - TreeMap


    - Properties


    - LinkedHashMap



- 类方法
- 类方法
- 类方法
- 类方法
- 类方法
- 类方法
- 类方法
- 类方法
- 类方法
- 类方法
- 类方法
- 类方法
- 类方法
- 类方法
- 类方
