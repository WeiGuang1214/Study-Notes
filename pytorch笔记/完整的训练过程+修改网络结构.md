## 1、加载模型+预训练权重

```python
from torch import nn
vgg16_false = torchvision.models.vgg16(pretrained=False) # 不带预训练权重
vgg16_true = torchvision.models.vgg16(pretrained=True) # 带预训练权重

print(vgg16_true) # 可以查看网络的结构，层次
train_data = torchvision.datasets.CIFAR10('../data',train=True,transform=torchvision.transforms.ToTensor(),download=True) # 加载数据集
vgg16_true.add_module('add_linear',nn.Linear(1000,10)) # 添加层，参数对应维度

vgg16_true.classifier[6] = nn.Linear(4096,10) # 在classifier中修改层，参数对应维度
```



## 2、加载模型+保存模型

```python
from torch import nn
vgg16_false = torchvision.models.vgg16(pretrained=False) # 不带预训练权重
# 方式1 模型结构+参数
torch.save(vgg16_false,"vgg16_epoch1.pth") # save 保存模型和对应的权重

model = torch.load("vgg16_epoch1.pth") # load 加载模型和对应的权重

# 保存方式2，仅保存参数
torch.save(vgg16.state_dict(),"vgg16_epoch1.pth") # 把参数保存成字典

```

## 3、完整的训练+测试过程

```py
from torch import nn
# 加载数据集
train_data = torchvision.datasets.CIFAR10('../data',train=True,transform=torchvision.transforms.ToTensor(),download=True) # 加载数据集 并且转换数据集的类型
test_data = torchvision.datasets.CIFAR10('../data',train=False,transform=torchvision.transforms.ToTensor(),download=True) # 加载测试数据集

# 查看数据集情况
train_data_size = len(train_data)
print("训练数据集的长度：{}".fomate(train_data_size))

# 利用dataloader来加载数据集
train_dataloader = DataLoader(train_data,batch_size=64)
test_dataloader = DataLoader(test_data,batch_size=64)

# 搭建神经网络
class Tudeui(nn.Module):
    def __init__(self):
        super(Tudui,self).__init__()
        self.model = nn.Sequential(
        	nn.Conv2d(3,32,5,1,2),
            nn.MaxPool2d(2),
            nn.Conv2d(32,32,5,1,2),
            nn.MaxPool2d(2),
            nn.Conv2d(32,64,5,1,2),
            nn.Flatten(),
            nn.Linear(64*64,64),
            nn.Linear(64,10)
        )
    def forward(self,x):
        x = self.model(X)
        return x
if __name__ == '__main__':
	tudui = Tudui()    # 模型单独拿出去的时候可以不用if函数，直接新建一个tudui对象，然后使用这个模型
    # 损失函数
    loss_fn = nn.CrossEntropyLoss()
    # 优化器,lr也可以单独写出来
    optimizer = torch.optim.SGD(tudui.parameters(),lr=0.01)
    #记录训练网络的参数
    #记录训练的次数
    total_train_step = 0
    total_test_step = 0
    #训练轮数
    epoch = 10
    
    # 添加tensorboard 查看结果
    writer = SummaryWriter("../logs_train")
    
    for i in range(epoch):
        print("--第{}轮训练开始".fomate(i+1))
        
        # 训练开始
        for data in train_dataloader:
            imgs,targets = data
            outputs = tudui(imgs)
            loss = loss_fn(outputs,targets)
            # 优化器
            optimizer.zero_grad()
            loss.backward()
            optimizer.step()
            total_train_step = total_train_step +1
            if total_train_step % 100 ==0:     # 百次的时候才打印训练记录
            	print("训练次数:{},Loss:{}".formate(total_train_step,loss.item())) # item把torch数据类型转换为数字
       			writer.add_scalar("train_loss",loss.item(),total_train_step)
    
        # 测试步骤
        # 求整个模型上的损失
        total_test_loss = 0
   	    with torch.no_grad():
            for data in test_dataloader:
                imgs,targets = data
                outputs = tuudi(imgs)
                loss = loss_fn(outputs,targets)
                total_test_loss += loss.item()
                # 求整体的准确度
                accuracy = (outputs.argmax(1)==targets).sum()
                toltalaccuracy = totalaccuracy + accuracy
        print("整体数据集上的测试loss：{}".format(total_test_loss))
        print("整体数据集上的准确度：{}".format(total_accuracy/total_test_step))
        writer.add_scalar("test_loss",total_test_loss,total_test_step)
        writer.add_scalar("test_accuracy",total_accuracy,total_test_step)
        total_test_step += 1  
        
        torch.save(tudui,"tudui_{}.pth".format(i))  # 保存模型
        print("模型已保存")
writer.close()

# 对于模型的输出，outputs，多目标分类的时候会有多个输出结果，是类别的概率
# 例如：
'''
outputs = torch.tensor([0.1,0.2],
                       [0.3,0.4])
print(outputs.argmax(1))  # 第一行的最大值就是相应的预测值
preds = outputs.argmax(1)
targets = torch.tensor([0,1])  # 

'''

```

![](https://github.com/WeiGuang1214/Study-Notes/blob/master/images/1730018643155.jpg)

## 利用GPU训练

找到数据集，模型，损失函数可以在GPU计算

```py
from torch import nn
import time
# 训练的设备
device = torch.device("cpu")

# 加载数据集
train_data = torchvision.datasets.CIFAR10('../data',train=True,transform=torchvision.transforms.ToTensor(),download=True) # 加载数据集 并且转换数据集的类型
test_data = torchvision.datasets.CIFAR10('../data',train=False,transform=torchvision.transforms.ToTensor(),download=True) # 加载测试数据集

# 查看数据集情况
train_data_size = len(train_data)
print("训练数据集的长度：{}".fomate(train_data_size))

# 利用dataloader来加载数据集
train_dataloader = DataLoader(train_data,batch_size=64)
test_dataloader = DataLoader(test_data,batch_size=64)

# 搭建神经网络
class Tudeui(nn.Module):
    def __init__(self):
        super(Tudui,self).__init__()
        self.model = nn.Sequential(
        	nn.Conv2d(3,32,5,1,2),
            nn.MaxPool2d(2),
            nn.Conv2d(32,32,5,1,2),
            nn.MaxPool2d(2),
            nn.Conv2d(32,64,5,1,2),
            nn.Flatten(),
            nn.Linear(64*64,64),
            nn.Linear(64,10)
        )
    def forward(self,x):
        x = self.model(X)
        return x
if __name__ == '__main__':
	tudui = Tudui()    # 模型单独拿出去的时候可以不用if函数，直接新建一个tudui对象，然后使用这个模型
    # 也可以直接转移到device上去
    tudui = tudui.to(device)
    
    # 良好的习惯，cuda可用再转移到cuda
    if torch.cuda.is_available():
    	tudui = tudui.cuda()  # 调用cuda，在GPU训练
    # 损失函数
    loss_fn = nn.CrossEntropyLoss()
    # 也可以直接转移到device上去
    loss_fn = loss_fn.to(device)
    
    # 良好的习惯，cuda可用再转移到cuda
    if torch.cuda.is_available():
    	loss_fn = loss_fn.cuda()
    
    # 优化器,lr也可以单独写出来
    optimizer = torch.optim.SGD(tudui.parameters(),lr=0.01)
    #记录训练网络的参数
    #记录训练的次数
    total_train_step = 0
    total_test_step = 0
    #训练轮数
    epoch = 10
    
    # 添加tensorboard 查看结果
    writer = SummaryWriter("../logs_train")
    start_time = time.time()
    for i in range(epoch):
        print("--第{}轮训练开始".fomate(i+1))
        
        # 训练开始
        for data in train_dataloader:
            imgs,targets = data
            # 良好的习惯，cuda可用再转移到cuda
    	    if torch.cuda.is_available():
           		imgs = imgs.cuda()
           		targets = targets.cuda()
            
            outputs = tudui(imgs)
            loss = loss_fn(outputs,targets)
            # 优化器
            optimizer.zero_grad()
            loss.backward()
            optimizer.step()
            total_train_step = total_train_step +1
            if total_train_step % 100 ==0:     # 百次的时候才打印训练记录
                end_time = time.time()
                print("训练花费时间:{},Loss:{}".formate(end_time-start_time))
            	print("训练次数:{},Loss:{}".formate(total_train_step,loss.item())) # item把torch数据类型转换为数字
       			writer.add_scalar("train_loss",loss.item(),total_train_step)
    
        # 测试步骤
        # 求整个模型上的损失
        total_test_loss = 0
   	    with torch.no_grad():
            for data in test_dataloader:
                imgs,targets = data
                # 良好的习惯，cuda可用再转移到cuda
    		   if torch.cuda.is_available():
                	imgs = imgs.cuda()
           		    targets = targets.cuda()
                outputs = tuudi(imgs)
                loss = loss_fn(outputs,targets)
                total_test_loss += loss.item()
        print("整体数据集上的测试loss：{}".format(total_test_loss))
        writer.add_scalar("test_loss",total_test_loss,total_test_step)
        total_test_step += 1  
        
        torch.save(tudui,"tudui_{}.pth".format(i))  # 保存模型
        print("模型已保存")
writer.close()
```

### 第二种方法GPU训练：.to(device)方法，模型、损失和数据都可以转移到GPU上运行

```python
.to(device)
device = torch.device("gpu")
Torch.device("cuda")
Torch.device("cuda:0")

# 损失函数
    loss_fn = nn.CrossEntropyLoss()
    # 也可以直接转移到device上去
    loss_fn = loss_fn.to(device)
```

## 测试一个训练好的模型

```py
test.py
from PIL import Image
# 首先是确定绝对路径，或者相对路径，建议全部绝对路径，一步到位
image_path = "../images/dogs.png"
image = Image.open(image_path)
print(image)

tarnsform = torchvision.transforms.Compose([torchvision.tranforms.Resize(32,32),
                                           torchvision.transforms.ToTensor()])

model = torch.load("tudui_0.pth")
model.eval()
with torch.no_grad():
    output = model(image)
print(output)
```

