##### 文档注释

- ​	javadoc -d 文件夹名 -xx -yy Demo3.java

- ​	写在类之前，可以显示当前文档的相关信息

- ```java
  /**
  *@author XXX
  *@version 1.0
  */
  ```

- ​	相对路径：当前目录开始定位形成的一个路径

- ​	..\表示回到上一级

- ​	..\ ..\hello.java两个表示回到上两级

- ​	绝对路径：从根目录出发形成的路径

- ​	d:\abd\test.....\hello.java


##### DOS命令

- ​	dir	查看当前文件夹的文件

- ​	dir d:\xxx	查看当前具体文件夹里的文件

- ​	help cd 	查看当前指令的作用

- ​	cd /D c:	切换到其他盘

- ​	cd 相对路径或者绝对路径	切换到其他具体目录下

- ​	cd ..	切换到上一级

- ​	cd \	切换到根目录

- ​	tree	查看当前指定目录的所有子目录，目录树

- ​	cls	清屏

- ​	exit	退出DOS

- ​	md	创建目录

- ​	rd	删除目录

- ​	copy 拷贝文件

- ​	del 删除文件

- ​	echo 输入内容到文件

- ​	type	输入空文件

- ​	move	剪切


##### 数据类型

##### 引用数据类型：数组、类、接口

##### 基本数据类型：

- ​	byte 字节，一个字节8bit

- ​	int 4byte

- ​	short 2byte

- ​	long 8byte，500L，后面接L

- ​	float 4byte，浮点数=符号位+指数位+尾数位，尾数部分可能丢失，造成精度损失(小数都是近似值)，后面接f或者F

- ​	double float 8byte，

- ​	浮点数的计数方式有两种：十进制计数，一定要有小数点，5.1,5.10F，.512F，.512==0.512；

- ​	科学计数法：512E-2==512*10的-2次，521E2==52100，double / float和int计算还是float，特别重要：判断两个数是否相等，应该是两个数差值的绝对值小于10的-6，因为有可能存在误差

- ​	char 单个字符，char c1 = 'a';	char c2 = '\t';	char c3 = '飞';	char c4 = '85'；char类型可以加减，对应数值

- ​	A-Z是65-90

- ​	a-z是97-122

- ​	boolean 布尔，逻辑值，1byte，true or false


##### 数据类型自动转换：

- ​	小自动转大，自动转换类型：

- ​		char->int->long->float->double

- ​		byte->short->int->long->float->double

- ​		char和byte不能自动转换

- ​	大转小要强制转换：


​		

##### Java API文档

​	API是Java提供的基本编程接口，由Java自带的类还有相关的方法，中文在线文档：https：//www.matools.com；包里有接口、类、异常![image-20240718203857619](C:\Users\微光\AppData\Roaming\Typora\typora-user-images\image-20240718203857619.png)

##### 运算符

- 注意/前后的类型，      类似10/4=2,10.0/4=2.5

- -10 % 3= -1    a%b=a-a/b*b

- ##### 当a是小数时，a % b = a-(int)a  /b * b，小数运算是近似值

- 10% -3= 1  ，注意公式

- -10 % -3 = -1  ，可以理解为散列表向左向右，以0为中轴

- 自增，自减，i++，i--，++i，--i，注意独立使用和结合赋值使用的区别

- ##### 关系运算

- ==    !=  < >   <=   >=    instance of  判断是否属于类的对象

- ##### 逻辑

- &&  ||    且，或

- &  逻辑与，作用和&&相同，但是前后都要判断，|  逻辑或，同样两边都要判断

- !a  非

- a ^ b    逻辑异或，ab不同的时候为true ，否则为false

- ##### 赋值

- == ，+= ，-=    复合赋值会进行类型强制转换，注意报错

- ##### 三元运算符

- result = a>b ? a++ : b-- ;	注意先处理返回 和 后计算表达式的运算	要注意类型的转换，三元不可以强制转换

- ##### 运算符的优先级

- 只有   单目运算、赋值运算  是从右往左	，其余都是从左往右

- ##### 运算顺序：

- 1、()   ,   {} 等

- 2、单目运算 ++ --

- 3、算术运算符

- 4、位移运算符 <<  >> >>> 

- 5、比较运算符

- 6、逻辑运算符

- 7、三元运算符

- 8、赋值运算符

- 先单目，再算术运算，再比较  再看逻辑大小


##### 标识符规范

​	驼峰命名，不能用关键字和保留字，注意特殊字符，

##### 输入

- java.util.Scanner 类

- Scanner scanner = new Scanner(System.in);

- String name = scanner.next() 字符串

- int a = scanner.nextInt() 什么类型就用什么结尾

- double salary = scanner.nextDouble() 什么类型就用什么结尾


#### 进制转换

- ##### 1、二、八、十六转十进制

- 存在0b开头，2：个位开始乘2的(位数-1)次方，求和

- 0开头八进制，8：个位开始乘8的(位数-1)次方，求和

- 0x开头十六进制，16：个位开始乘16的(位数-1)次方，求和

- ##### 2、十进制转二、八、十六

- 除余再整除，保留余数，逆置就是进制转换结果

- 0b

- 0

- 0x

- ##### 3、二进制转八、十六进制

- 2转8：从低位开始每三个数一组，转成对应10进制即可，最后数排起来就是8进制

- 2转16：从低位开始每四个数一组，转成对应10进制即可，最后数排起来就是16进制

- ##### 4、八、十六进制转二进制

- 8转2：每一位转成3位2进制

- 16转2：每一位转成4位2进制

- ##### 位运算

- ##### 二进制最重要的第一位是符号位，0是正，1是负

- ##### 正数的原码、反码、补码都一样，三码合一

- 负数求反码，负号位不变，其余的求反码

- 负数的补码=反码+1

- 负数的反码=补码-1

- 0的反码补码都是0

- 右移>>：移动几位，除以2的几次方，整除形式

- 左移<<：移动几位，乘以2的几次方

- 无符号右移>>>：

- ##### 这四则运算都是先转换为补码再运算

- ~按位取反：0变1,1变0，正数的反码是其本身，*负数的反码是符号位保持不变*，其余位取反

- &按位与：每位每位的对比，同时为1结果为1，否则为0

- |按位或：至少有一个1结果为1，否则为0

- ^按位异或：两个一个为0一个为1，否则为0

- ##### 结果返回要转换为原码（最后print为10进制），注意负号的情况


##### 顺序控制

- 分支控制 if

- 双分支 if else、嵌套

- 多分支switch：


```java
switch(表达式):{  //表达式只能是 byte int short char string enum[]
    case '常量1':
    	语句块1;
    	break;  //  有退出的时候，匹配了退出，否则没有匹配，继续往后判断
    // 如果匹配了没有break，会一直执行后面的语句块，default也会执行，直到break   穿透
    case '常量2':
    	语句块2: 
    	break; 
    default:  // 如果前面没有匹配就默认执行，然后break，可有可无
    	语句块;
    	break;
}
```

- 需要注意的是表达式和case后的常量类型一致或者可以相互转换，char->int，case后必须常量，加 ' '

- ##### for循环  

- for(int i = 0;i<100;i++){     //   ；；为死循环

- }   // i++可以写入循环体内，i的作用域在循环体内也有效

- ##### while循环

- while(条件){

- 循环体

- }

- ##### do while循环。dowhile是关键字

- do先会执行一次，不论循环对错都会执行一次

- do{

- }while(条件);

- 循环条件返回的是布尔值的表达式

- ##### 多重循环控制，嵌套，注意内外变量

- ##### break跳出循环  continue 继续下一次循环

- break可以利用标签label指明要终结的是哪一层循环


```java
label1:
for(int j =0;j<4;j++){
label2:
	for(){
		if(){
			break label1;
		}
	}
} //break到哪，推出到哪个label
```

- 没有label默认退出最近的循环

- ##### return 返回值，或return;，表示跳出所在的方法，如果在main里面return就是结束程序

- ##### 数组，数组是引用类型，类型是Object


##### 动态初始化，数组初始化没赋值都是类型的默认值

- 1、类型 名字[] = new 类型[大小]   int a[] = new int[10];    数组名[下标]  a[2]  从0开始
- 2、先声明，再new一个，先声明再创建   int a[];   a[] = new[10];

- 3、静态初始化，直接赋值，下标越界会报错

##### 数组赋值机制，数组复制是引用，传递的是地址，地址传递的修改会修改原本的数据结构

​	int a1[] = {1,2,3};  int a2[] = a1;，不修改值的拷贝是for循环复制

##### JVM的内存：栈、堆、方法区

- 数组的翻转，原地换位

- 数组动态(利用do while，复制给一个大一位的数组)、静态扩容


##### 数组应用：排序、查找、栈、队列、顺序存储

- 二维数组

- ```java
  for (int i=0;i<a.length;i++){
              for (int j=0;j<a[i].length;j++){
    //二维数组  第一维长度：a.length  ，第二维长度：a[i].length
              }
          }
  ```

- 动态初始化：int a //[ ]//[ ] = new int //[2]//[3]

- 二维数组，一维的a[]其实是存的数组名，a//[]//[]为二维数组的值，地址取值方式

- a指向的是数组首地址，以此类推

- 动态定义：int a//[]/[];  ，再new  a = new int [2]//[3] 


##### 类与对象

​	类class .属性，.方法     生成对象  ，调用属性方法

```java
class AA{

	String aaa;
	基本数据类型、引用、数组、类的对象
	int num;
}
AA xiaoa = new AA()
xiaoa.aaa=
xiaoa.num=
```

#### 方法

- ##### 访问修饰符

- public   protected   默认  private

- 类的对象开辟空间

- ##### Java 内存的结构分析

- 1、栈：存储基本的数据类型，局部变量

- 2、堆：存放对象，数组等

- 3、方法区：常量池、类加载信息

- 创建流程：先加载类信息(属性和方法)，在堆中开辟空间默认初始化，把地址返回给对象，进行指定初始化

- ##### 成员方法

- 类里面定义，对象调用，程序执行到方法才开辟空间，注意方法返回值，输入参数

- ##### 访问修饰符控制方法的访问范围 public  private  默认不写  protected

- 方法只能有一个返回值，方法参数传值，数组等等引用类型，传递的是地址，可以修改到具体变量

- ##### 递归，注意递归出口，递归条件

- ##### 方法的重载

- ##### 	重载的前提是方法名相同，允许多个同名方法存在，但是形参列表，重点是参数类型、参数个数、顺序不能一样，对方法的修饰符、返回类型无要求

#### 可变参数

- 允许把同一类中多个同名同功能但参数个数不同的方法，封装成一个方法，可以通过可变参数实现

- int...表示类型int的0-多个参数，nums可以当可变场数组，实参可以是数组，可变参数就是数组，可以通过下标访问全部参数，可变参数可以和普通参数写在一起，但是可变参数一定要放在最后，一个形参列表最多只能一个可变参数

- ```java
  public int sum(int... nums){
  
  }
  ```

- 全局变量（类内属性,默认初始化），局部变量（方法内，需要初始化）的作用域

- 全局变量可以用访问控制符修饰，但是局部变量不可以

#### 构造方法/构造器，对新对象的初始化

- 构造器的修饰符可以默认，也可以随意，
- 构造器没有返回值
- 方法名必须和类名一致
- 构造器的调用是由系统完成的
- 构造器也能重载
- 系统有无参默认的构造器，自己定义也可以无参构造器
- 对象创建的流程，栈、堆、方法区
- 注意无参构造器中嵌套有参构造器this()
- ##### this关键字

​	Java虚拟机给每个对象分配this，代表当前对象，this.name=name，this.hashCode可以简单看成内部地址，哪个对象调用，this就代表哪个对象，this只能在构造器中使用，可以在一个构造器中访问另外一个构造器，this可以直接使用构造器，this()，里面赋值传参

#### 面向对象编程

- **IDEA快捷键：**

  - **ctrl +d 删除行**
  - **ctrl+alt+向下光标  复制当前行**
  - **alt+/ 补全代码**
  - **ctrl+/ 添加注释，再按取消**
  - **导入该行需要的类，alt+enter**
  - **快速格式化，ctrl+shift+L**
  - **快速运行程序，自己定义 ctrl+r**
  - **生成构造器等 alt+insert**
  - **查看类的层级关系   ctrl+H**
  - **定位到哪个类的方法  ctrl+B** 
  - **自动分配变量名    .var**     例：new Scanner(System.in).var

- 包

  - package 包名;  打包，import导入包，管理类，package只能放在第一句
  - 命名规则：数字、字母、下划线、小圆点，但是不能数字开头且关键字、保留字     ：   公司名.项目名.模块名
  - 基本包，自动导入：java.lang.*
  - 工具包：java.util.*
  - 网络包：java.net.*
  - GUI界面开发：java.awt.*

- ##### 访问修饰符

  - public  对外公开
  - protected 子类和同一个包中的类公开
  - 默认 没有修饰符，对同类、同包公开
  - private 私有，只有类本身访问
  - 只有默认和public可以修饰类


- ##### 封装

  - 把抽象出的数据（属性）和对数据的操作（方法）封装在一起，数据被保护在内部，在程序的其他部分通过被授权的方法操作属性
  - 隐藏实现细节、可以对数据进行验证，保证安全合理
  - 实现封装：
    - 属性私有化，private，外部不能修改
    - 公共set方法，用于对属性判断并且赋值，将构造器和set方法结合在一起写
    - 提供一个公共get方法，用于获得属性的值

- ##### 继承

  - 解决代码复用，降低冗余，从父类中定义相同的属性和方法，用子类extends继承父类即可使用属性和方法
  - class 子 extends 父{}
  - **子类继承所有属性和方法，但是私有属性不能在子类直接访问，但是可以通过父类的公共方法访问**
  - 子类必须首先调用父类的无参构造器，完成父类的初始化，如果父类没有无参构造器，就要用super关键字指定用父类哪个构造器构造，super(参数列表)
  - super()在构造器中只能放在第一行，并且super()和this()不能同时存在一个构造器中
  - Java所有类都是Object的子类，只能单继承
  - 父类的构造器调用不限于父类，可能一直调用祖先的构造器

- ##### super关键字

  - super代表父类的引用，用于访问父类的属性、方法和构造器
  - 父类属性：super.属性，但是不能访问私有属性
  - 父类方法：super.方法，但是不能访问私有方法
  - 构造器：super(参数列表 )


- ##### 方法重写/覆盖   override

  子类继承父类的方法后重写父类的方法，定义的形式一样：名称、返回类型、参数列表一样

  - 子类不能缩小父类的访问权限
  - 方法重写/覆盖   override

- #### 多态

  - 多态建立在封装和继承的基础上-->两个(对象)类有继承关系
  - 方法的多态：重写和重载
  - 对象的多态(核心)：
    - 对象的编译类型和运行类型可以不一致
    - 编译类型在定义对象的时候就确定了，不能改变
    - 运行类型是可以变的
    - 编译类型看定义=左边，运行类型看=右边，属性的值只看编译类型，方法的调用看运行类型
    - getclass()查看运行类型
  - **多态：向上转型**
    - 父类的引用指向子类的对象     父类  引用名 = new 子类()
    - 可以调用父类的所有成员，遵守(遵守访问权限)，不可以调用子类的特有成员，因为在编译阶段能调用的成员是由编译类型决定，
  - **多态：向下转型**
    - 子类的引用指向父类的对象   子类  引用名 = (子类类型)父类引用，强制转换引用，地址一样
    - 只能强转父类的引用，不能强制转换父类的对象
    - 可以调用子类类型中所有的成员
    - 要求父类的引用必须指向的是当前目标类型的对象
    - 属性没有重写之说，属性的值只看编译类型
    - instanceOf  判断xx运行类型是否属于x类型或者子类型   a  instanceOf  b  true or false

- #### **Java动态绑定机制**

  
  - 当调用对象方法的时候，该方法会和对象的内存、运行类型绑定
  
  - 当调用对象属性的时候，没有动态绑定机制，哪里声明(当前类)，哪里使用
  
- #### 多态数组

  - 数组的定义类型为父类类型，里面保存的实际元素类型为子类类型，编辑类型是父类，运行类型实际根据JVM来
  - 如何调用子类特有的方法，比如Teacher对象，统一放在数组中，调用每个对象的say

- #### 多态参数

  - 方法定义的形参类型为父类类型，实参类型允许为子类类型
  
- ##### Object类详解

  
  - equals方法，equals和==的区别，==是比较运算符，equals是方法
  
  - Object内的equals判断对象是不是同一个，equals不能判断值是否相等，Object子类重写后的equals判断值，String的equals重写过了，判断值是否相等
  
  - ==既可以判断基本类型也可以判断引用类型，值/地址(对象)是否相等
  
  - 对于基本数据类型，==是判断值是否相等
  
- hashCode返回hash码值

  - 两个引用，如果指向的是同一个对象，哈希值就一样，不同则不一样
  - 哈希值主要是根据地址号，但是不等于地址，Java跑在虚拟机上，所以不能获得内部地址
  
- ##### toString

  
  - 返回类的全类名和hashcode
  - 重写toString，输出对象的属性值，直接输出一个对象的时候，默认调用toString
  
- ##### finalize类


    - 对象被回收的时候，释放空间，调用finalize方法，子类可以重写该方法


    - 垃圾回收机制由系统自动调用，但是也可以自己主动调用，System.gc()，主动运行垃圾回收器，不会造成程序阻塞



- ##### 断点调试


    - 在断点调试的过程中，是运行状态，是以对象的运行类型来执行的
    - F7 跳入方法内；F8逐行运行；shift+F8 跳出方法；F9 resume 执行到下一个断点


    - 强制进入源码   alt shift F7


    - 方法定义的形参类型为父类类型，实参类型允许为子类类型


- ##### 类变量

  - static 类变量，静态变量，会被该类所有的对象实例共享，不管存在哪里，
  - 类变量在类加载的时候就生成了
  - 通过类名.变量名；对象.变量名；
  - 在所有对象共享一个变量的时候，把变量声明成类变量
  - 属性(实例变量)不能通过类名访问，只能通过对象访问
  - 类对象的生命周期随类的加载和销毁而加载和销毁


  - ##### 类方法


    - 类名.方法名；对象名.方法名，static方法，静态方法
    
    - 当成工具直接调用
    
    - 类方法中不允许有this和super关键字
    
    - 静态方法只能调用静态变量和静态方法
    
    - 非静态方法既可以访问静态变量、静态方法，也可以访问非静态变量、非静态方法



- ##### main方法

  - JAVA虚拟机调用，所以main方法必须是public
  - java虚拟机调用main方法不需要创建对象，所以是static类型的
  - args字符串数组用来保存java执行命令的参数
  - main是静态方法，所以可以使用静态变量和方法
  
- ##### 代码块

  - [修饰符]{代码}；
  - 修饰符要写只能写static
  - 相当于是另一种的构造器，可以做初始化操作，如果多个构造器有重复的语句，就可以抽象出来，放在代码块里面，代码块的调用优先于构造器
  - static代码块，随着类的加载只会执行一次，静态代码块只能调用静态成员
  - 普通代码块随着对象创建都会执行，创建一次执行一次
  - 一个类加载时候代码块和构造方法的调用顺序：

    - 父类静态代码块的执行按顺序调用，谁在前就先执行
    - 子类静态代码块的执行按顺序调用，谁在前就先执行
    - 父类普通代码块的执行按顺序调用，谁在前就先执行
    - 父类构造器
    - 子类普通代码块的执行按顺序调用，谁在前就先执行
    - 子类构造器
    - 构造器其实隐藏了super()和调用普通代码块的语句
  
- ##### 类在什么时候加载？

  - 创建对象实例时（只加载一次）
  - 创建子类对象实例时，父类会被加载
  - 使用类的静态成员（静态方法，静态属性）
  
- ##### 单例设计模式

  - 静态方法和属性的经典使用
  - 单个对象实例从头用到尾
  - 饿汉式：

    - 构造器私有化、类的内部创建对象、向外暴露一个公共方法getInstance、代码实现
  - 懒汉式：
    - 构造器私有化、内部定义一个私有属性对象、向外暴露一个公共方法getInstance，在getInstance方法内，如果检查属性对象是null就创建对象，返回对象，保证单例
  
- ##### final关键字
  
  - 修饰类、属性、方法、局部变量
  - 不希望类被继承、不希望被子类覆盖或重写、不希望某个属性的值被修改、不希望某个变量被修改
  - 定义时必须初始化，但是可以在构造器，代码块中赋值
  - final类不能被继承，但是可以实例化对象
  - 如果不是final类，但是如果方法是final，是可以被继承的
  - 如果一个类已经是final类，就不用再把方法变成final方法
  
- #### 抽象类
  
  - 父类的某些方法需要声明，但是不知道怎么实现的时候，可以用抽象方法，这个类叫抽象类
  - 没有方法体：
    - abstract void eat();   如果存在抽象方法即要声明为抽象类   abstract class
    - abstract只能修饰类和方法，如果一个类继承了抽象类就必须实现抽象类的所有方法，否则自己也是一个抽象类
    - 抽象方法不能被private final static来修饰，因为这些修饰和重写相违背
    - 抽象类重点是设计，子类继承后实现方法具体内容，抽象类可以没有抽象方法
  
- ##### 抽象模版模式
  
  - 把公共代码放在父类继承，个性化任务用抽象类，子类重写实现各自功能
  
- 接口interface，给出一些没有实现的方法，封装到一起，在某个类具体使用的时候再把方法写出来

  - ```java
    interface{
    	属性
        方法(抽象方法、默认实现方法、静态方法)
    }
    class 类名 implements 接口{
        自己属性
        自己方法
        必须实现的接口的抽象方法
    }  //接口中可以有方法的具体实现，实现接口的时候需要把接口内的所有方法都实现
    ```

    

  - public interface UsbInterface{	接口相关的方法}

  - public class phone implement UsbInterface{         }

  - 接口类声明方法，implement具体实现重写方法

  - 接口不能实例化，所有方法都是public，抽象方法可以不用abstract修饰

  - 抽象类实现接口可以不用实现接口的方法

  - 可以同时实现多个接口，逗号隔开

  - **接口中的属性其实是public static final 的**

  - 接口的修饰符只能是public和默认，这个和类一样，接口只能继承接口，不能继承类

  - 接口机制是对继承机制的补充，子类如果需要扩展功能需要实现接口，接口更灵活

- ##### 接口的多态特性

  - 1、多态参数：接口的引用可以指向实现了接口类的对象

  - 2、多态数组：和继承一样，如果接口引用需要实现类特有的方法，需要向下转型再调用

  - 3、多态传递：类似于子类的多层继承，接口的继承，可以实现到父类接口

  - 一个类可以同时继承和实现接口

- ##### 内部类

  - **类的五大成员：构造器、属性、方法、代码块、内部类**

  - A类里面嵌套B类：内外只是相对关系，内部类、外部类、外部其他类

  - 局部位置：

    - **局部内部类，有类名**

      - 地位是局部变量，不能用访问修饰符，但是可以用final，只能在定义它的方法和代码块中用，访问方法需要创建内部类对象，如果成员重名就就近原则，访问外部对象：类名.this.成员

    - **匿名内部类，无类名(重点)**

      - 本质是类，内部类，没有名字，**同时也是一个对象，可以直接new一个接口然后重写方法**

      - ```java
        new 类或接口(参数列表){类体};
        ```

        anonymous ，底层会分配一个匿名类名，用一次就销毁，简化开发，注意使用时和对象的创建分开，需要注意{};

        参数列表会传递给构造器

        可以调用匿名内部类的方法，直接匿名内部类.方法，也可以建好对象后.方法

        **匿名内部类如果重名，是一种继承，并且可以重写方法**

    - **成员内部类**，没有static修饰，可以添加任意访问修饰符，本质是成员变量

    - **静态内部类**，有static修饰，静态成员，作用域和其他成员一样，为一个整体

      #### 枚举

- enum，一组常量的集合，**只能读不能修改**

  - 1、自定义类实现的枚举

    - 在类的内部直接创建一组对象

    - 私有化构造器

    - 对外暴露对象public static 类型，可以用final

    - 只有get方法，不用set

  - 2、使用enum关键字定义的枚举

    - 如果使用enum实现枚举，要求把常量对象定义在前面，用逗号隔开

    - 如果使用无参构造器创建常量对象，小括号和参数可以省略

    - ```java
      enum class{
          duix1(a,b),duix2(a,b);
          私有属性；
          私有构造器
      }
      ```

      enum枚举实际上继承了final Enum类，

      ```java
      枚举对象.name() 返回名字
      枚举对象.ordinal() 返回次序、编号
      类名.values() 返回数组，里面是枚举对象
          A[] values = A.values();
      	for(A a:values){} //增强for循环
      类名.valueOf("String") 把字符串常量转成枚举对象，要求常量名是存在的枚举对象
      枚举对象.compareTo(枚举对象) ,比较两个枚举对象的编号是否相同，返回值是A-B编号
      ```

      enum类实现接口的问题：

      ​	1、不能继承任何类，已经继承Enum了

      ​	2、枚举类和普通类一样可以实现接口


- 注解annotation，源数据，用于修饰解释包、类、方法等信息
  - 使用的时候要在前面加一个@
  - @Override：重写父类方法，语法校验，如果真的重写，编译通过，没有就编译不通过
  - @Deprecated：某个方法已经过时，但是可以用
  - @SuppressWarnings({})：抑制编译器警告，当不想看到编译器警告的时候用这个注解，在{}内填写不想显示的信息
  
- #### 异常

  - 利用try-catch机制
  - try{代码块}catch(Exception e){getmessage}
  - 分为error(资源耗尽、栈溢出)和exception(编译、运行)两类
  - exception：

    - 数组越界、空指针、算数异常、类型转换异常
  - 异常处理：

    - try-catch-finally，程序员捕获自行处理，不管有没有异常都要执行finally
    - throws，往上一级抛出，最终交给JVM处理，JVM直接输出异常程序并且中断，如果没有显式try catch就是默认throws

  - 自定义异常

    - 编译异常继承exception，运行异常继承runtime exception，编译类型需要在方法显式throws，运行类型可以直接方法内throw
    - throw和throws的区别：
    - throws是异常处理的一种方式(方法声明中)，后跟异常类型；throw是生成异常对象的关键字(方法体内)，后跟异常对象；
  
- #### 包装类

  - 基本数据类型对应的包装类，具有类的特征，可以调用类中的方法
  - Boolean、Character、Byte、Short、Integer、Long、Float、Double，包装类是number的子类
  - int和String的相互转化：i.toString、String.valueof(i)、

    - String str = “123”；Integer i = new Integer(str)、Integer i = Integer.parseInt(str)
  - 常用方法：
  
    - MIN_VALUE,返回最小值
    - MAX_VALUE,返回最大值
    - Character类：
    - isDigit('a')，判断是不是数字
    - isLetter('a')  判断是不是字母
    - isUpperCase('a') 判断是不是大写
    - isLowerCase('a') 判断是不是大写
    - isWhitespace('a') 判断是不是空格
    - toUpperCase('a')  转大写
    - toLowerCase('a')  转小写
    - 只要是基本数据类型，==判断的是值，否则是判断引用对象是否一个
  
- #### String类

  - String字符串用来保存字符序列，可以用数组初始化，不能被继承，字符串对象指定之后不能改变地址，但是可以改变字符串内容，不可变，如果String是相同对象，返回的就是同一个地址
  - 1、直接赋值：先看常量池里面有没有，有就指向地址，没有就创建再指向
  - 2、调用构造器创建String对象：先在堆里面创建空间，内部有value属性，然后再指向常量池，没有则创建，最终指向的是堆里面的空间
  - 如果是字符串相加，是在常量池新增字符串对象，如果是对象相加，是在堆里面创建对象
  - String常用方法：
    - str.equals()，判断值相等
    - equalsIgnoreCase()，忽略大小写判断是否相等
    - length()，长度
    - indexOf()，字符第一次出现的下标
    - lastIndexOf()，字符最后一次出现的下标
    - substring(x,y)，截取指定范围的子串
    - trim()去掉前后空格
    - charAt()，获取某索引处的字符
    - concat()，拼接
    - replace()，代替
    - split()，以X分隔，返回数组
    - str.toCharArray()，转成字符数组
  
- #### StringBuffer类，线程安全

  - 可变的字符序列，里面放的是字符串变量，value放在堆内，大小可以变
  - String->StringBuffer可以指定char[]大小，StringBuffer stringbuff = new StringBuffer(100)；
  - toString也可以转成字符串，也可以用String的构造器
  - 常用方法：
    - append、delete、replace、insert、length
  
- #### StringBuilder类

  - 单线程使用，线程不安全
  - 和StringBuffer兼容，用在字符串缓冲区被单个线程使用的时候，大多数时候比StringBuffer快，主要用append和insert方法
  - 大量字符串修改用StringBuffer或StringBuilder
  - 单线程用StringBuilder，多线程用StringBuffer
  - 字符串很少修改用String

- #### Math类

  - 基本数学运算方法

    - abs()绝对值
    - pow()求幂，x的y次
    - ceil()大于等于该参数的最小整数，转成double
    - floor()小于等于该参数的最大整数，转成double
    - round()四舍五入，返回long
    - sqrt()开方，返回double
    - random() 返回0-1之间的double随机数  0<=  x<1  a<=<=b的随机数：(int)(a+Math.random()*(b-a+1))
    - max()、min()最大最小

- #### Arrays类

  - Arrays.toString() ，显示数组信息
  - Arrays.sort()，排序，底层快排
  - Arrays.binarySearch(),二分查找，要求必须有序
  - Arrays.copyOf(),复制数组
  - Arrays.fill()，用xx填充，覆盖数组
  - Arrays.equals(a,b) ，比较两个数组元素一致
  - Arrays.asList() ， 把数组转化成列表

- #### System类
  
  - 常用方法：
    - exit()，退出当前程序
    - arraycopy()，复制数组
    - currentTimeMillis()，返回当前时间距离1970-1-1的毫秒数
    - gc()，垃圾回收机制
  
- #### 大数类


  - BigInteger，运算不能用+-*/

    - 用字符串的方式new对象
    - add()加、subtract()减法、multiply()乘法、divide()除法

  - BigDecimal，大精度小数

    - 也用字符串构建
    - 也需要单独创建个对象，并且用方法实现运算add()加、subtract()减法、multiply()乘法、divide()除法(用BigDecimal.ROUND_CEILING保存精度)

- Date类、Calendar、


  - Date：

    - 日期精确到毫秒，SimpleDateFormat()格式化解析日期，日期to文本，文本to日期+
    - 通过毫秒数得到日期，parse()，把字符串日期转Date

  - Calendar：

    - 抽象类，构造器私有，用getInstance()获得实例
    - 通过对象.get获得Calendar的一个字段

  - LocalDate日期、LocalTime时间、LocalDateTime日期时间、DateTimeFormatter格式化日期、Instant时间戳

    - now()当前时间对象，get()获得字段，plus()和minus()可以对时间进行加减

- #### 集合


    - 动态保存任意多个对象，方便操作，add()，remove()，set()，get()等


    - 单列集合只放值，双列集合放KV对



  - ##### collection单列集合


      - add()添加、remove()删除、size()大小、isEmpty()判空、clear()清空、addAll()添加多个、cointainsAll()查找多个、removeAll()



      - 增强for：for(Object i：nums) ，和迭代器不同



      - 迭代器Iterator，通过.iterator新建迭代器对象，通过while遍历，再次遍历需要重置迭代器，
    - next，下一个元素并返回
    
    - hasNext，判断是否有下一个元素，remove删除



```java
Iterator iter = col.iterator();
while(iter.hasNext()){
    Object o = iter.next();
}
```


​      

  - (1) List，有序，添加顺序和取出顺序一致，并且元素可以重复，add，remove，set，get按索引，subList，查改较多的用ArrayList，增删较多的用LinkedList，可以通过索引获得元素，是Collection的子接口
    - ##### ArrayList

      - 可以存null，是由数组实现的，基本等同于vector，线程不安全，所以多线程不建议使用ArrayList，底层代码扩容机制：无参：容量初始为0，->10，再变为1.5倍，有参：容量指定，如需扩容直接1.5倍
    - ##### LinkedList
      
      - 实现了双向链表和双端队列，元素可以重复，可以null，线程不安全，没有实现同步
      - 底层是双向链表，每个节点node，删除添加不是数组完成的，效率较高，first和last指针
      
    - ##### Vector
      
      - 底层也是数组，是线程同步，线程安全的synchronized，扩容如果是无参，默认10，满了2倍，有参直接2倍扩容


  - (2) Set，无序，添加和取出顺序不一样，没有索引，不允许重复元素、所以对多包含一个null，也是Collection的子接口，但是不能使用索引获取元素，可以用增强for和迭代器循环，但是取出的顺序是固定的
    
    - ##### HashSet
    
      - 实现了set接口，底层实际上是HashMap，不保证存取顺序一致，HashSet在底层扩容是用链式哈希表，数组+链表，Java8中哈希表链表长度>8，tabl>64会变成红黑树
      - 添加逻辑：先比较哈希值(hashCode)，哈希值相同的会放在同一个地址下的链表，然后判断equals是不是值相同，相同就添加，否则添加，所以String重写equals方法和hashCode方法，所以new String的时候就无法添加，其他类也是一样，如果重写就无法添加new对象
      - LinkedHashSet，继承HashSet，底层是LinkedHashMap，底层维护数组+双向链表，依旧根据元素的hashCode决定存放位置，通过底层的双向链表保证了元素的次序，不允许添加重复元素
    - ##### TreeSet
      
      - 排序，在用无参构造器初始化的时候仍然是无序；使用TreeSet提供的构造器可以传入一个比较器(匿名内部类)，并且指定顺序，底层是TreeMap，通过comparable实现比较排序


- #### Map双列集合，K-V对

  - 用于保存具有映射关系的Key-value；map中的Key-value可以是任何对象，被封装在HashMap$Node中；Key不允许重复，实现原理和HashSet一样；但是Value可以重复，key关键字相当于索引，key和value都可以为null但是key只能有一个，value可以多个
  
  - ```java
    1、通过keySet返回key集合，然后增强for循环遍历getvalue
    2、entryset迭代器
    Set entrySet = map.entrySet();
            Iterator iterator = entrySet.iterator();
            while(iterator.hasNext()){
                Map.Entry entry = (Map.Entry)iterator.next();
                System.out.println(entry.getKey()+":"+entry.getValue());
            }
    3、values方法返回集合
        Collection collection = map.values(); // 返回value集合
            for(Object value:collection){
                System.out.println(value);
            }
    ```
    
    

```java
- HashMap

- put添加、添加key相同的value会覆盖上一个value，经常用String作为key；
    get(key)  获取对应的value；
    size()  大小
    isEmpty()    判空
    containsKey()	查找key是否存在，
    containsValue() 查找值是否存在，
    remove(key)或者kv对、
    putAll(Map)、clear()、
    keySet关键字集合、values()值的集合、
    equals判断相同，
    getOrDefault返回value、
    entrySet返回entry集合

    - 遍历方法：1、获得keySet，通过key增强for获得value；2、迭代器获得key，迭代get；3、把所有value取出，可以使用所有的Collection方法；也可以通过entrySet使用增强for和迭代器，向下转型成Map.entry
HashMap没有实现同步机制，所以是线程不安全的

HashMap底层维护Node类型的table，默认为null
创建对象的时候加载因子loadfactor初始化为0.75
添加k-v时，先通过K的哈希值得到table的索引，然后判断该索引处有没有元素，没有直接添加，有则判断元素的key是否相同，相同就替换val，不相同则要判断是树结构还是链表结构，做出相应处理，添加时容量不够要扩容
第1次添加，table扩容到16，临界值变成12
以后再一次扩容变成2倍，临界值为原来2倍，以此类推
一条链表长度超过8，并且table的大小>64才会变成红黑树，否则就扩容

```


    - Hashtable
    存放的元素是KV对，并且key和value都不能为空，抛出null异常
    使用方法和HashMap类似
    Hashtable是线程安全的，HashMap是线程不安全的
    扩容机制：边界值依然是0.75，超过边界大小会*2再+1，以此类推



    - TreeMap


    - Properties
    继承了Hashtable，间接实现map接口，也是KV对保存数据，不能为空，使用和Hashtable类似，properties通常作为配置文件，在IO流中，加载数据到Properties对象中


    - LinkedHashMap

根据开发需要，判断存储类型，一组对象或者一组键值对，

一组对象用Collection接口，允许重复用List，增删改较多用LinkedList，查找较多用ArrayList

##### 						不允许重复用Set，无序用HashSet(底层是HashMap)，排序用TreeSet，插入和取出顺序一致用LinkedHashSet

一对键值对用Map

​	键无序用HashMap

​	键排序用TreeMap

​	键插入和取出顺序一致用LinkedHashMap

​	读取文件用Properties

- ##### Collection工具类
  
  - 操作Set、List和Map等集合的工具类，静态方法对集合元素进行排序、查询修改
  - reverse(List)，反转
  - shuffle(List)，对List内元素随机排序，打乱
  - sort(List)，集合排序
  - sort(List，Comparator)，按照比较器进行排序
  - swap(List,i,j)，交换元素
  - max(Collection)，返回自然顺序最大值
  - min()最小
  - frequency(集合，对象)，返回出现次数
  - copy()复制
  - replaceAll(List list，Obj old，Obj new)，替换
  
- #### 泛型

  - 编译的时候检查对象类型，在类声明或者实例化的时候，指定好需要的具体类型即可，参数化类型，解决数据安全性问题

  - ```Java
    class A<E>{
    	E a;
    }
    ```

  - E表示对应a的数据类型，在定义A对象的时候指定

  - 泛型的声明，interface 接口<E>{}   和class类<E>{}，如果没有指定泛型，默认是Object类型，所以后续都要向下转型成对象再调用成员，和方法；但是如果指定泛型，就可以直接用指定的类型，不用向下转型

  - 自定义泛型：

    - 普通成员可以使用泛型(属性，方法)
    - 使用泛型的数组，不能初始化
    - 静态方法中不能使用类的泛型(属性，方法)
    - 泛型类的类型是在创建时候确定的
    - 如果在创建对象时没有指定就是Object

  - 泛型方法：

  - public <A,B> void AAAa(T t, R r)

    提供给方法使用的，然后在使用方法的时候，根据传入的类型，确定TR的类型

  - 泛型不具备继承性，所以不能上下转型，<?> c表示任意类型，<? extends AA> c表示任意AA，或者AA的子类，上限

  - <? super AA> c表示任意AA，或者AA的父类，下限

  - 泛型接口：

    - 静态方法中不能使用泛型(属性，方法)
    - 泛型接口的类型，在继承接口或者实现接口的时候确定
    - 没有指定默认就是Object

- ##### JUnit单元测试

- ##### Java画图

  - Component提供两个和绘图相关最重要的方法；
  - paint(Graphics g)绘制组件的外观
  - repaint()刷新组件的外观
  - 画图过程：

  - 1、画图类继承Jpanel类，画图形，是一个画板，重写绘图方法pain，一定要保留super.paint(g)；

    - Graphics提供了很多画图的方法，g.drawXXX，画图形

  - 2、主类需要继承JFrame，Java画图框架，图形都在框架内，新建一个对象就可以画图

  - 3、需要在JFrame框架内，定义画板对象；在构造方法中把画板添加到窗口中，设置大小，设置Visible可视化；

  - 当组件第一次在屏幕上显示的时候，程序会自动调用paint来绘制组件，以下情况会出现调用paint()

  - 4种情况：第一次在屏幕上显示的时候、窗口大小发生变化，最小化再最大化的时候，repaint的时候

  - 

  - Graphics类相当于是一个画笔

    - 画直线：drawLine(x1,y1,x2,y2)
    - 画矩形边框 drawRect(x,y,width,height)
    - 画圆形边框 drawOval(x,y,width,height)
    - 填充矩形 fillRect(x,y,width,height)
    - 填充椭圆 fillOval(x,y,width,height)
    - 画图片 drawImage(img,x,y)
    - 画字符串 drawString(str,x,y)
    - 画笔字体 setFont(font)
    - 画笔颜色 setColor(color)

    

- #### Java事件处理机制

  - Java时间处理是”委派事件模型“，事件发生的时候会产生事件对象，把信息传递给事件监听者处理，信息其实是java.awt.event中的某个类创建的对象，称之为事件的对象
  - 事件源->事件->时间监听者->事件处理方法
  - 事件源：产生事件的对象，按钮、窗口等；
  - 事件：承载事件源状态改变时的对象，比如键盘事件、鼠标事件、窗口事件等等，会产生一个事件对象，保存很多信息，比如KeyEvent，含有按下键盘的Code值，java.awt.event包和javax.swing.event中包含了各种事件类型

- #### 多线程基础

  - 进程：运行的程序，进程是程序一次的执行过程，或者是正在运行的一个程序，是动态的过程，有自身产生、存在和消亡的过程，操作系统会为进程分配内存空间
  - 线程是由进程创建的，是进程的一个实体。一个进程可以有很多个线程
  - 进程是资源分配的基本单位，线程是调度的基本单位
  - 单线程：同一个时刻只允许执行一个线程
  - 多线程：同一时刻多个线程同时执行
  - 并发：同一个时刻，多个任务交替执行，因为切换速度快，所以造成貌似同时的错觉，单核CPU实现多任务就是并发
  - 并行：同一个时刻，多个任务同时执行，多核CPU可以实现并行
  - 并发和并行可能同时存在
  - runtime.getAvaibaleProcessors()，获得当前电脑可用CPU数目

- #### Java线程创建的两种方式

  - 1、继承Thread类，重写run方法

    - 继承Thread就可以当线程使用，重写run方法，实现自己的业务代码，run thread类是实现了Runnable接口的run方法，对象.start启动线程，真正实现线程的是start()方法，start方法中可以有很多个start0()方法

  - 2、实现Runnable接口，重写run方法，但是实现runnable接口之后，是没有start方法的，不能对象.start()，需要创建thread，把子线程对象放进去，然后由thread对象创建，Thread thread = new Thread(dog)；thread.start()；底层实现了静态代理；

  - runnable接口适合多线程共享一个资源的情况，避免了单继承的限制

  - #### 多线程机制：

  - 进程中会有一个main线程，main线程启动一个子线程 Thread-0，主线程不会阻塞，会继续执行。主线程和子线程会交替执行，如果是单核就是并发，多核是并行

  - jconsole，java监视和管理平台，所有的线程结束了，进程才会挂掉，并且run方法只是一个主线程的方法，执行完才向下串行，而start，是启动子线程，多线程实现

  - ##### 线程终止：怎么通知线程退出

  - 1、线程完成任务之后自动退出

  - 2、通过使用变量的方式，在run方法中停止线程，终止

  - 线程常用方法：

  - setName设置线程名称；getName返回该线程的名称；start启动线程，java虚拟机会底层调用start0方法；run调用线程对象的run方法；setPriority更改线程的优先级1-5-10；getPriority获得线程的优先级；sleep休眠毫秒；interrupt中断线程，中断不代表结束，一般中断休眠，唤醒；

  - 线程yield，礼让；让出cpu，让其他线程执行，但礼让的时间不确定，所以也不一定礼让成功

  - 线程插队。join，插队之后会让该线程执行完，然后再去执行当前线程的剩余任务

- ###### 用户线程，也叫工作线程，任务执行完，或者通知方式结束

- ###### 守护线程，为工作线程服务的，当所有工作线程结束，守护线程才结束DaemonThread

  - 如果想让子线程在主线程结束之后也结束，就需要设置为守护线程，setDaemon(True)

- #### 线程的7大状态：

  - Thread.State枚举表示了线程的几种状态
  - NEW，未启动，新创建的
  - Runnable，可运行状态，不一定真正运行，取决于操作系统
    - Ready就绪状态
    - Running运行状态
  - TimedWaiting 超时等待，sleep
  - Waiting可能被插队或者wait的等待
  - Blocked，进入同步代码块的锁
  - TERMINATED终止状态

- ##### 线程同步

  - 在多线程编程中，一些敏感数据不允许被多个线程同时访问，此时就使用同步访问技术，保证数据在如何同一时刻，最多有一个线程访问，以保证数据的完整性
  - 即当有一个线程对内存进行操作的时候，其它线程都不可以对这个内存地址进行操作，直到该线程完成操作，其它线程才能对内存地址操作

- ##### Synchronized

  - 同步代码块
  - 还可以在方法中，表示整个方法为同步方法
    - public synchronized void fun(){}
  
- #### 互斥锁

  - Java用对象互斥锁来保证共享数据操作的完整性，每个对象都对应于一个互斥锁标记，在任一时刻，只能有一个线程访问该对象
  - 关键字synchronized来于对象的互斥锁联系，当某个对象用synchronized修饰的时候，表示该对象在任一时刻只能由一个线程访问
  - 同步的局限性：导致程序的执行效率很低
  - 同步方法（非静态的）的锁可以是this也可以是其他对象（要求是同一个对象）
  - 同步方法（静态的）的锁是当前类本身
    - 在方法当中，对代码块，方法可以用synchronized(this){}修饰，表示这部分代码块或者方法，实现了同步方法，即上锁；这时锁在this对象
    - 非静态的方法和代码块，也可以用对象上锁，synchronized(object){}
    - 静态方法的锁是当前类本身：public synchronized static void m1(){} 锁是加在 SellTicket03.class   
    - 如果是静态方法中的代码块上锁，应该在synchronized修饰后加当前类，synchronized(){当前类名.class}  
    - this是非公平锁

- ##### 互斥锁使用注意事项：

  - 同步方法如果没有使用static修饰，默认锁对象是this
  - 如果方法使用了static修饰，默认锁对象是：当前类.class
  - 实现锁的步骤：
    - 需要先分析上锁代码，选择同步代码块或者同步方法，然后保证多个线程的锁对象是同一个即可

- ##### 线程死锁：

  - 多个线程都占用了对方的锁资源，但是不肯相让，导致了死锁

- ##### 释放锁

  - 线程的同步方法、同步代码块执行结束

  - 在同步方法、同步代码块遇到break、return

  - 遇到error或者exception

  - 执行了wait()方法，当前线程暂停

  - ##### 以下操作不会释放锁：

  - 在执行同步的时候，程序调用了Thread.sleep()，Thread.yield()，程序只会暂停当前线程执行，不会释放锁

  - 当执行同步的时候，其它线程调用了当前线程的suspend方法，挂起了线程，也不会释放当前锁，尽量避免使用suspend和resume方法

- #### IO流

  - 文件在程序中是以流的方式操作，java程序在内存中，文件在磁盘中，磁盘到内存是输入流，内存到磁盘是输出流
  - 创建文件：
    - File file = new File(filePath)   直接填文件创建的路径；然后file.createNewFile()
    - File parentFile = new File("e:\ \ \");    String fileName = "new.txt"    File file = new File(parentFile,fileName);  父目录+子文件
    - File parentFile = new File("e:\ \ \");    String fileName = "new.txt"    File file = new File(parentFile,fileName);   父目录+子路径
  - 获取文件信息
    - getName()；获取名字
    - getAbsolutePath；绝对路径
    - getParent；父目录
    - length；大小（字节）
    - exists；是否存在
    - isFile；是否为文件
    - isDirectory；是否为目录
  - 目录的操作和文件删除，Java中目录也是文件
    - mkdir()创建一级目录；mkdirs()创建多级目录；

- ##### Java IO流原理

  - Java程序中对于数据的输入/输出是以流stream的方式读取
  - java.io包中提供了各种流的类和接口
  - 按操作数据单位不同分为：字节流8bit，字符流
  - 按数据流的流向：输入、输出
  - 输入流       字节流（二进制文件） InputStream      字符流（文本文件）Reader
  - 输出流       字节流                            OutputStream             字符流         Writer
  - 都是抽象类，所以要创建实现子类
  - 文件和流的区别，文件是数据存储形式，流是传输形式

- 类方法

- 类方法

- 类方法

- 类方法

- 类方法

- 类方法

- 类方法

- 类方
